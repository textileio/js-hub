## API Report File for "@textile/hub"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ArchiveInfoReply } from '@textile/buckets-grpc/buckets_pb';
import { ArchiveReply } from '@textile/buckets-grpc/buckets_pb';
import { ArchiveStatusReply } from '@textile/buckets-grpc/buckets_pb';
import { ArchiveWatchReply } from '@textile/buckets-grpc/buckets_pb';
import CID from 'cids';
import { ContextInterface } from '@textile/context';
import { Datastore } from 'interface-datastore';
import { Dispatcher } from '@textile/threads-store';
import { DomainDatastore } from '@textile/threads-store';
import { EventEmitter } from 'tsee';
import { EventEmitter2 } from 'eventemitter2';
import { grpc } from '@improbable-eng/grpc-web';
import { Identity } from '@textile/threads-core';
import { InitReply } from '@textile/buckets-grpc/buckets_pb';
import { Instance } from '@textile/threads-store';
import { JsonPatchStore } from '@textile/threads-store';
import { JSONSchema4 } from 'json-schema';
import { JSONSchema6 } from 'json-schema';
import { JSONSchema7 } from 'json-schema';
import { Libp2pCryptoIdentity } from '@textile/threads-core';
import { LinksReply } from '@textile/buckets-grpc/buckets_pb';
import { ListIpfsPathReply } from '@textile/buckets-grpc/buckets_pb';
import { ListPathItem } from '@textile/buckets-grpc/buckets_pb';
import { ListPathReply } from '@textile/buckets-grpc/buckets_pb';
import { ListReply } from '@textile/buckets-grpc/buckets_pb';
import log from 'loglevel';
import { LogInfo } from '@textile/threads-core';
import { Multiaddr } from '@textile/multiaddr';
import { name as name_2 } from 'multibase';
import { Network } from '@textile/threads-network';
import { Options as Options_2 } from 'async-retry';
import * as pb from '@textile/threads-client-grpc/threads_pb';
import { PullIpfsPathReply } from '@textile/buckets-grpc/buckets_pb';
import { PullPathReply } from '@textile/buckets-grpc/buckets_pb';
import { PushPathReply } from '@textile/buckets-grpc/buckets_pb';
import { Query } from 'interface-datastore';
import { ReadTransactionReply } from '@textile/threads-client-grpc/threads_pb';
import { ReadTransactionRequest } from '@textile/threads-client-grpc/threads_pb';
import { RemovePathReply } from '@textile/buckets-grpc/buckets_pb';
import { RemoveReply } from '@textile/buckets-grpc/buckets_pb';
import { Result } from 'interface-datastore';
import { Root } from '@textile/buckets-grpc/buckets_pb';
import { RootReply } from '@textile/buckets-grpc/buckets_pb';
import { SetPathReply } from '@textile/buckets-grpc/buckets_pb';
import { ThreadKey } from '@textile/threads-core';
import { ThreadRecord } from '@textile/threads-core';
import { ValidateFunction } from 'ajv';
import { WriteTransactionReply } from '@textile/threads-client-grpc/threads_pb';
import { WriteTransactionRequest } from '@textile/threads-client-grpc/threads_pb';

// @public
export type APISig = {
    sig: string;
    msg: string;
};

export { ArchiveInfoReply }

export { ArchiveReply }

export { ArchiveStatusReply }

export { ArchiveWatchReply }

// @public
export class Buckets extends BucketsGrpcClient {
    // @beta
    archive(key: string): Promise<ArchiveReply.AsObject>;
    // @beta
    archiveInfo(key: string): Promise<ArchiveInfoReply.AsObject>;
    // @beta
    archiveStatus(key: string): Promise<ArchiveStatusReply.AsObject>;
    // @beta
    archiveWatch(key: string, callback: (reply?: {
        id: string | undefined;
        msg: string;
    }, err?: Error) => void): Promise<() => void>;
    getOrInit(name: string, threadName?: string, isPrivate?: boolean, threadID?: string): Promise<{
        root?: Root.AsObject;
        threadID?: string;
    }>;
    getToken(identity: Identity): Promise<string>;
    getTokenChallenge(publicKey: string, callback: (challenge: Uint8Array) => Uint8Array | Promise<Uint8Array>): Promise<string>;
    init(name: string, isPrivate?: boolean): Promise<InitReply.AsObject>;
    links(key: string): Promise<LinksReply.AsObject>;
    list(): Promise<Root.AsObject[]>;
    listIpfsPath(path: string): Promise<ListPathItem.AsObject | undefined>;
    listPath(key: string, path: string, depth?: number): Promise<ListPathReply.AsObject>;
    listPathFlat(key: string, path: string, dirs?: boolean, depth?: number): Promise<ListPathFlat>;
    // @deprecated
    open(name: string, threadName?: string, isPrivate?: boolean, threadID?: string): Promise<{
        root?: Root.AsObject;
        threadID?: string;
    }>;
    pullIpfsPath(path: string, opts?: {
        progress?: (num?: number) => void;
    }): AsyncIterableIterator<Uint8Array>;
    pullPath(key: string, path: string, opts?: {
        progress?: (num?: number) => void;
    }): AsyncIterableIterator<Uint8Array>;
    pushPath(key: string, path: string, input: any, opts?: {
        progress?: (num?: number) => void;
    }): Promise<PushPathResult>;
    remove(key: string): Promise<void>;
    removePath(key: string, path: string, root?: string): Promise<void>;
    root(key: string): Promise<Root.AsObject | undefined>;
    static withKeyInfo(key: KeyInfo, host?: string, debug?: boolean): Promise<Buckets>;
    withThread(threadID?: string): this | undefined;
    static withUserAuth(auth: UserAuth | (() => Promise<UserAuth>), host?: string, debug?: boolean): Buckets;
}

// @beta
export function bucketsArchive(api: BucketsGrpcClient, key: string, ctx?: ContextInterface): Promise<ArchiveReply.AsObject>;

// @beta
export function bucketsArchiveInfo(api: BucketsGrpcClient, key: string, ctx?: ContextInterface): Promise<ArchiveInfoReply.AsObject>;

// @beta
export function bucketsArchiveStatus(api: BucketsGrpcClient, key: string, ctx?: ContextInterface): Promise<ArchiveStatusReply.AsObject>;

// @beta
export function bucketsArchiveWatch(api: BucketsGrpcClient, key: string, callback: (reply?: {
    id: string | undefined;
    msg: string;
}, err?: Error) => void, ctx?: ContextInterface): Promise<() => void>;

// @public (undocumented)
export class BucketsGrpcClient {
    constructor(context?: ContextInterface, debug?: boolean);
    // (undocumented)
    context: ContextInterface;
    // (undocumented)
    rpcOptions: grpc.RpcOptions;
    // (undocumented)
    serviceHost: string;
    // (undocumented)
    unary<R extends grpc.ProtobufMessage, T extends grpc.ProtobufMessage, M extends grpc.UnaryMethodDefinition<R, T>>(methodDescriptor: M, req: R, ctx?: ContextInterface): Promise<T>;
}

// @public
export function bucketsInit(api: BucketsGrpcClient, name: string, isPrivate?: boolean, ctx?: ContextInterface): Promise<InitReply.AsObject>;

// @public
export function bucketsLinks(api: BucketsGrpcClient, key: string, ctx?: ContextInterface): Promise<LinksReply.AsObject>;

// @public
export function bucketsList(api: BucketsGrpcClient, ctx?: ContextInterface): Promise<Array<Root.AsObject>>;

// @public
export function bucketsListIpfsPath(api: BucketsGrpcClient, path: string, ctx?: ContextInterface): Promise<ListPathItem.AsObject | undefined>;

// @public
export function bucketsListPath(api: BucketsGrpcClient, key: string, path: string, ctx?: ContextInterface): Promise<ListPathReply.AsObject>;

// @public
export function bucketsPullIpfsPath(api: BucketsGrpcClient, path: string, opts?: {
    progress?: (num?: number) => void;
}, ctx?: ContextInterface): AsyncIterableIterator<Uint8Array>;

// @public
export function bucketsPullPath(api: BucketsGrpcClient, key: string, path: string, opts?: {
    progress?: (num?: number) => void;
}, ctx?: ContextInterface): AsyncIterableIterator<Uint8Array>;

// @public
export function bucketsPushPath(api: BucketsGrpcClient, key: string, path: string, input: any, opts?: {
    progress?: (num?: number) => void;
}, ctx?: ContextInterface): Promise<PushPathResult>;

// @public
export function bucketsRemove(api: BucketsGrpcClient, key: string, ctx?: ContextInterface): Promise<void>;

// @public
export function bucketsRemovePath(api: BucketsGrpcClient, key: string, path: string, root?: string, ctx?: ContextInterface): Promise<void>;

// @public
export function bucketsRoot(api: BucketsGrpcClient, key: string, ctx?: ContextInterface): Promise<Root.AsObject | undefined>;

// @public
export function bytesToArray(chunk: Uint8Array, size?: number): Uint8Array[];

// @public
export class Client {
    constructor(context?: ContextInterface, debug?: boolean);
    // (undocumented)
    context: ContextInterface;
    create(threadID: ThreadID, collectionName: string, values: any[]): Promise<string[]>;
    delete(threadID: ThreadID, collectionName: string, IDs: string[]): Promise<void>;
    deleteCollection(threadID: ThreadID, name: string): Promise<void>;
    deleteDB(threadID: ThreadID): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "QueryJSON" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "InstanceList" needs to be exported by the entry point index.d.ts
    find<T = any>(threadID: ThreadID, collectionName: string, query: QueryJSON): Promise<InstanceList<T>>;
    // Warning: (ae-forgotten-export) The symbol "Instance" needs to be exported by the entry point index.d.ts
    findByID<T = any>(threadID: ThreadID, collectionName: string, ID: string): Promise<Instance_2<T>>;
    getCollectionIndexes(threadID: ThreadID, name: string): Promise<pb.Index.AsObject[]>;
    getDBInfo(threadID: ThreadID): Promise<DBInfo_2>;
    getToken(identity: Identity, ctx?: ContextInterface): Promise<string>;
    getTokenChallenge(publicKey: string, callback: (challenge: Uint8Array) => Uint8Array | Promise<Uint8Array>, ctx?: ContextInterface): Promise<string>;
    has(threadID: ThreadID, collectionName: string, IDs: string[]): Promise<boolean>;
    // Warning: (ae-forgotten-export) The symbol "DBInfo" needs to be exported by the entry point index.d.ts
    joinFromInfo(info: DBInfo_2, includeLocal?: boolean, collections?: Array<{
        name: string;
        schema: any;
    }>): Promise<void>;
    listDBs(): Promise<Record<string, pb.GetDBInfoReply.AsObject | undefined>>;
    // Warning: (ae-forgotten-export) The symbol "Filter" needs to be exported by the entry point index.d.ts
    listen<T = any>(threadID: ThreadID, filters: Filter[], callback: (reply?: Instance_2<T>, err?: Error) => void): grpc.Request;
    newCollection(threadID: ThreadID, name: string, schema: any, indexes?: pb.Index.AsObject[]): Promise<void>;
    newCollectionFromObject(threadID: ThreadID, name: string, obj: any, indexes?: pb.Index.AsObject[]): Promise<void>;
    newDB(threadID?: ThreadID, name?: string): Promise<ThreadID>;
    newDBFromAddr(address: string, key: string | Uint8Array, collections?: Array<{
        name: string;
        schema: any;
    }>): Promise<void>;
    open(threadID: ThreadID, name?: string): Promise<void>;
    static randomIdentity(): Promise<Libp2pCryptoIdentity>;
    // Warning: (ae-forgotten-export) The symbol "ReadTransaction" needs to be exported by the entry point index.d.ts
    readTransaction(threadID: ThreadID, collectionName: string): ReadTransaction;
    // (undocumented)
    rpcOptions: grpc.RpcOptions;
    save(threadID: ThreadID, collectionName: string, values: any[]): Promise<void>;
    // (undocumented)
    serviceHost: string;
    updateCollection(threadID: ThreadID, name: string, schema: any, indexes?: pb.Index.AsObject[]): Promise<void>;
    static withKeyInfo(key: KeyInfo, host?: string, debug?: boolean): Promise<Client>;
    static withUserAuth(auth: UserAuth | (() => Promise<UserAuth>), host?: string, debug?: boolean): Client;
    // Warning: (ae-forgotten-export) The symbol "WriteTransaction" needs to be exported by the entry point index.d.ts
    writeTransaction(threadID: ThreadID, collectionName: string): WriteTransaction;
}

// @public (undocumented)
export interface Collection<T extends Instance = any> {
    // (undocumented)
    (data: Partial<T>): Document_2<T> & T;
    // (undocumented)
    new (data: Partial<T>): Document_2<T> & T;
}

// @public
export class Collection<T extends Instance = any> extends ReadonlyCollection<T> {
    constructor(name: string, schema: JSONSchema, options?: Options<T>);
    delete(...ids: string[]): Promise<void>;
    insert(...instances: T[]): Promise<void>;
    // (undocumented)
    readonly name: string;
    readTransaction(cb: (c: ReadonlyCollection<T>) => Promise<void> | void, timeout?: number): Promise<void>;
    save(...entities: T[]): Promise<void>;
    writeTransaction(cb: (c: Collection<T>) => Promise<void> | void, timeout?: number): Promise<void>;
}

// @public (undocumented)
export interface Config {
    // (undocumented)
    name: string;
    // (undocumented)
    schema: JSONSchema;
}

// @public
export function createAPISig(secret: string, date?: Date): Promise<APISig>;

// @public
export function createUserAuth(key: string, secret: string, date?: Date, token?: string): Promise<UserAuth>;

// @public (undocumented)
export class Database implements DatabaseSettings {
    constructor(store: Datastore<any> | string, options?: Partial<DatabaseSettings>);
    child: DomainDatastore<any>;
    close(): Promise<void>;
    collections: Map<string, Collection>;
    dispatcher: Dispatcher;
    emitter: EventEmitter2;
    // Warning: (ae-forgotten-export) The symbol "EventBus" needs to be exported by the entry point index.d.ts
    eventBus: EventBus;
    getDBInfo(asStrings?: boolean): Promise<DBInfo | undefined>;
    network: Network;
    newCollection<T extends Instance>(name: string, schema: JSONSchema): Promise<Collection<T>>;
    newCollectionFromObject<T extends Instance>(name: string, data: T): Promise<Collection<T>>;
    // (undocumented)
    ownLogInfo(): Promise<LogInfo | undefined>;
    static randomIdentity(): Promise<Libp2pCryptoIdentity>;
    start(identity: Identity, opts?: StartOptions): Promise<void>;
    startFromAddress(identity: Identity, addr: Multiaddr, threadKey?: ThreadKey, opts?: StartOptions): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "DBInfo" needs to be exported by the entry point index.d.ts
    startFromInfo(identity: Identity, info: DBInfo, includeLocal?: boolean, opts?: StartOptions): Promise<undefined | Error>;
    threadID?: ThreadID;
    // (undocumented)
    static withKeyInfo(keyInfo: KeyInfo, store: string | Datastore, options?: Partial<DatabaseSettings>, host?: string, debug?: boolean): Promise<Database>;
    static withUserAuth(auth: UserAuth | (() => Promise<UserAuth>), store: string | Datastore, options?: Partial<DatabaseSettings>, host?: string, debug?: boolean): Database;
}

// @public
export interface DatabaseSettings {
    child: Datastore<any>;
    dispatcher: Dispatcher;
    eventBus: EventBus;
    network: Network;
}

// @public
class Document_2<T extends Instance = any> {
    constructor(_collection: Collection<T>, _data: T);
    exists(): Promise<boolean>;
    remove(): Promise<void>;
    save(): Promise<void>;
    toJSON(): T;
}

export { Document_2 as Document }

// @public (undocumented)
export const existingKeyError: Error;

// @public
export const expirationError: Error;

// Warning: (ae-forgotten-export) The symbol "Condition" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "RootQuerySelector" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type FilterQuery<T = any> = {
    [P in keyof T]?: Condition<T[P]>;
} & RootQuerySelector<T>;

export { Identity }

export { InitReply }

// @public (undocumented)
export type JSONSchema = JSONSchema4 | JSONSchema6 | JSONSchema7;

// @public
export type KeyInfo = {
    key: string;
    secret?: string;
};

export { LinksReply }

export { ListIpfsPathReply }

// @public (undocumented)
export type ListPathFlat = ReturnType<typeof listPathFlat>;

// @public
export function listPathFlat(grpc: BucketsGrpcClient, bucketKey: string, path: string, dirs: boolean, depth: number): Promise<string[]>;

export { ListPathItem }

// @public (undocumented)
export type ListPathRecursive = ReturnType<typeof listPathRecursive>;

// @public
export function listPathRecursive(grpc: BucketsGrpcClient, bucketKey: string, path: string, depth: number, currentDepth?: number): Promise<ListPathReply.AsObject>;

export { ListPathReply }

export { ListReply }

// @public (undocumented)
export const mismatchError: Error;

// @public (undocumented)
export const missingIdentity: Error;

// @public
export interface Options<T extends Instance> {
    // (undocumented)
    child?: Datastore<T>;
    // (undocumented)
    dispatcher?: Dispatcher;
}

export { PullIpfsPathReply }

export { PullPathReply }

export { PushPathReply }

// @public
export interface PushPathResult {
    // (undocumented)
    path: {
        path: string;
        cid: CID;
        root: CID;
        remainder: string;
    };
    // (undocumented)
    root: string;
}

// @public (undocumented)
export class ReadonlyCollection<T extends Instance = any> {
    constructor(name: string, schema: JSONSchema, options?: Options<T>);
    child: JsonPatchStore<T>;
    count(query: FilterQuery<T>, options?: FindOptions<T>): Promise<number>;
    // Warning: (ae-forgotten-export) The symbol "FindOptions" needs to be exported by the entry point index.d.ts
    find(query?: FilterQuery<T>, options?: FindOptions<T>): AsyncIterable<Result<T>>;
    findById(id: string): Promise<T>;
    findOne(query: FilterQuery<T>, options?: FindOptions<T>): Promise<IteratorResult<Result<T>, any>>;
    // (undocumented)
    static fromCollection<T extends Instance>(other: Collection<T>): ReadonlyCollection<any>;
    has(id: string): Promise<boolean>;
    // (undocumented)
    readonly name: string;
    validator: ValidateFunction;
}

export { RemovePathReply }

export { RemoveReply }

export { Root }

export { RootReply }

export { SetPathReply }

// @public (undocumented)
export interface StartOptions {
    collections?: Config[];
    threadID?: ThreadID;
}

// @public
export class ThreadID {
    constructor(buf: Uint8Array);
    // (undocumented)
    readonly buf: Buffer;
    equals(o: ThreadID): boolean;
    static fromBytes(data: Uint8Array): ThreadID;
    static fromRandom(variant?: Variant, size?: number): ThreadID;
    static fromString(v: string | Uint8Array): ThreadID;
    static getEncoding(v: string): string;
    isDefined(): boolean;
    toBytes(): Buffer;
    toString(base?: name_2): string;
    static V1: number;
    // (undocumented)
    static Variant: typeof Variant;
    variant(): number;
    version(): number;
}

// @public
export type UserAuth = {
    key: string;
    sig: string;
    msg: string;
    token?: string;
};

// @public
export enum Variant {
    // (undocumented)
    AccessControlled = 112,
    // (undocumented)
    Raw = 85
}


```
