## API Report File for "@textile/hub"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ArchiveInfoReply } from '@textile/buckets-grpc/buckets_pb';
import { ArchiveReply } from '@textile/buckets-grpc/buckets_pb';
import { ArchiveStatusReply } from '@textile/buckets-grpc/buckets_pb';
import { ArchiveWatchReply } from '@textile/buckets-grpc/buckets_pb';
import CID from 'cids';
import { ContextInterface } from '@textile/context';
import { grpc } from '@improbable-eng/grpc-web';
import { Identity } from '@textile/threads-core';
import { InitReply } from '@textile/buckets-grpc/buckets_pb';
import { Libp2pCryptoIdentity } from '@textile/threads-core';
import { LinksReply } from '@textile/buckets-grpc/buckets_pb';
import { ListIpfsPathReply } from '@textile/buckets-grpc/buckets_pb';
import { ListPathItem } from '@textile/buckets-grpc/buckets_pb';
import { ListPathReply } from '@textile/buckets-grpc/buckets_pb';
import { ListReply } from '@textile/buckets-grpc/buckets_pb';
import { name as name_2 } from 'multibase';
import * as pb from '@textile/threads-client-grpc/threads_pb';
import { PullIpfsPathReply } from '@textile/buckets-grpc/buckets_pb';
import { PullPathReply } from '@textile/buckets-grpc/buckets_pb';
import { PushPathReply } from '@textile/buckets-grpc/buckets_pb';
import { ReadTransactionReply } from '@textile/threads-client-grpc/threads_pb';
import { ReadTransactionRequest } from '@textile/threads-client-grpc/threads_pb';
import { RemovePathReply } from '@textile/buckets-grpc/buckets_pb';
import { RemoveReply } from '@textile/buckets-grpc/buckets_pb';
import { Root } from '@textile/buckets-grpc/buckets_pb';
import { RootReply } from '@textile/buckets-grpc/buckets_pb';
import { SetPathReply } from '@textile/buckets-grpc/buckets_pb';
import { WriteTransactionReply } from '@textile/threads-client-grpc/threads_pb';
import { WriteTransactionRequest } from '@textile/threads-client-grpc/threads_pb';

// @public
export type APISig = {
    sig: string;
    msg: string;
};

export { ArchiveInfoReply }

export { ArchiveReply }

export { ArchiveStatusReply }

export { ArchiveWatchReply }

// @public
export class Buckets extends BucketsGrpcClient {
    // @beta
    archive(key: string): Promise<ArchiveReply.AsObject>;
    // @beta
    archiveInfo(key: string): Promise<ArchiveInfoReply.AsObject>;
    // @beta
    archiveStatus(key: string): Promise<ArchiveStatusReply.AsObject>;
    // @beta
    archiveWatch(key: string, callback: (reply?: {
        id: string | undefined;
        msg: string;
    }, err?: Error) => void): Promise<() => void>;
    getOrInit(name: string, threadName?: string, isPrivate?: boolean, threadID?: string): Promise<{
        root?: Root.AsObject;
        threadID?: string;
    }>;
    getToken(identity: Identity): Promise<string>;
    getTokenChallenge(publicKey: string, callback: (challenge: Uint8Array) => Uint8Array | Promise<Uint8Array>): Promise<string>;
    init(name: string, isPrivate?: boolean): Promise<InitReply.AsObject>;
    links(key: string): Promise<LinksReply.AsObject>;
    list(): Promise<Root.AsObject[]>;
    listIpfsPath(path: string): Promise<ListPathItem.AsObject | undefined>;
    listPath(key: string, path: string, depth?: number): Promise<ListPathReply.AsObject>;
    listPathFlat(key: string, path: string, dirs?: boolean, depth?: number): Promise<ListPathFlat>;
    // @deprecated
    open(name: string, threadName?: string, isPrivate?: boolean, threadID?: string): Promise<{
        root?: Root.AsObject;
        threadID?: string;
    }>;
    pullIpfsPath(path: string, opts?: {
        progress?: (num?: number) => void;
    }): AsyncIterableIterator<Uint8Array>;
    pullPath(key: string, path: string, opts?: {
        progress?: (num?: number) => void;
    }): AsyncIterableIterator<Uint8Array>;
    pushPath(key: string, path: string, input: any, opts?: {
        progress?: (num?: number) => void;
    }): Promise<PushPathResult>;
    remove(key: string): Promise<void>;
    removePath(key: string, path: string, root?: string): Promise<void>;
    root(key: string): Promise<Root.AsObject | undefined>;
    static withKeyInfo(key: KeyInfo, host?: string, debug?: boolean): Promise<Buckets>;
    withThread(threadID?: string): this | undefined;
    static withUserAuth(auth: UserAuth | (() => Promise<UserAuth>), host?: string, debug?: boolean): Buckets;
}

// @beta
export function bucketsArchive(api: BucketsGrpcClient, key: string, ctx?: ContextInterface): Promise<ArchiveReply.AsObject>;

// @beta
export function bucketsArchiveInfo(api: BucketsGrpcClient, key: string, ctx?: ContextInterface): Promise<ArchiveInfoReply.AsObject>;

// @beta
export function bucketsArchiveStatus(api: BucketsGrpcClient, key: string, ctx?: ContextInterface): Promise<ArchiveStatusReply.AsObject>;

// @beta
export function bucketsArchiveWatch(api: BucketsGrpcClient, key: string, callback: (reply?: {
    id: string | undefined;
    msg: string;
}, err?: Error) => void, ctx?: ContextInterface): Promise<() => void>;

// @public (undocumented)
export class BucketsGrpcClient {
    constructor(context?: ContextInterface, debug?: boolean);
    // (undocumented)
    context: ContextInterface;
    // (undocumented)
    rpcOptions: grpc.RpcOptions;
    // (undocumented)
    serviceHost: string;
    // (undocumented)
    unary<R extends grpc.ProtobufMessage, T extends grpc.ProtobufMessage, M extends grpc.UnaryMethodDefinition<R, T>>(methodDescriptor: M, req: R, ctx?: ContextInterface): Promise<T>;
}

// @public
export function bucketsInit(api: BucketsGrpcClient, name: string, isPrivate?: boolean, ctx?: ContextInterface): Promise<InitReply.AsObject>;

// @public
export function bucketsLinks(api: BucketsGrpcClient, key: string, ctx?: ContextInterface): Promise<LinksReply.AsObject>;

// @public
export function bucketsList(api: BucketsGrpcClient, ctx?: ContextInterface): Promise<Array<Root.AsObject>>;

// @public
export function bucketsListIpfsPath(api: BucketsGrpcClient, path: string, ctx?: ContextInterface): Promise<ListPathItem.AsObject | undefined>;

// @public
export function bucketsListPath(api: BucketsGrpcClient, key: string, path: string, ctx?: ContextInterface): Promise<ListPathReply.AsObject>;

// @public
export function bucketsPullIpfsPath(api: BucketsGrpcClient, path: string, opts?: {
    progress?: (num?: number) => void;
}, ctx?: ContextInterface): AsyncIterableIterator<Uint8Array>;

// @public
export function bucketsPullPath(api: BucketsGrpcClient, key: string, path: string, opts?: {
    progress?: (num?: number) => void;
}, ctx?: ContextInterface): AsyncIterableIterator<Uint8Array>;

// @public
export function bucketsPushPath(api: BucketsGrpcClient, key: string, path: string, input: any, opts?: {
    progress?: (num?: number) => void;
}, ctx?: ContextInterface): Promise<PushPathResult>;

// @public
export function bucketsRemove(api: BucketsGrpcClient, key: string, ctx?: ContextInterface): Promise<void>;

// @public
export function bucketsRemovePath(api: BucketsGrpcClient, key: string, path: string, root?: string, ctx?: ContextInterface): Promise<void>;

// @public
export function bucketsRoot(api: BucketsGrpcClient, key: string, ctx?: ContextInterface): Promise<Root.AsObject | undefined>;

// @public
export function bytesToArray(chunk: Uint8Array, size?: number): Uint8Array[];

// @public
export class Client {
    constructor(context?: ContextInterface, debug?: boolean);
    // (undocumented)
    context: ContextInterface;
    create(threadID: ThreadID, collectionName: string, values: any[]): Promise<string[]>;
    delete(threadID: ThreadID, collectionName: string, IDs: string[]): Promise<void>;
    deleteCollection(threadID: ThreadID, name: string): Promise<void>;
    deleteDB(threadID: ThreadID): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "QueryJSON" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "InstanceList" needs to be exported by the entry point index.d.ts
    find<T = any>(threadID: ThreadID, collectionName: string, query: QueryJSON): Promise<InstanceList<T>>;
    // Warning: (ae-forgotten-export) The symbol "Instance" needs to be exported by the entry point index.d.ts
    findByID<T = any>(threadID: ThreadID, collectionName: string, ID: string): Promise<Instance<T>>;
    getCollectionIndexes(threadID: ThreadID, name: string): Promise<pb.Index.AsObject[]>;
    getDBInfo(threadID: ThreadID): Promise<DBInfo>;
    getToken(identity: Identity, ctx?: ContextInterface): Promise<string>;
    getTokenChallenge(publicKey: string, callback: (challenge: Uint8Array) => Uint8Array | Promise<Uint8Array>, ctx?: ContextInterface): Promise<string>;
    has(threadID: ThreadID, collectionName: string, IDs: string[]): Promise<boolean>;
    // Warning: (ae-forgotten-export) The symbol "DBInfo" needs to be exported by the entry point index.d.ts
    joinFromInfo(info: DBInfo, includeLocal?: boolean, collections?: Array<{
        name: string;
        schema: any;
    }>): Promise<void>;
    listDBs(): Promise<Record<string, pb.GetDBInfoReply.AsObject | undefined>>;
    // Warning: (ae-forgotten-export) The symbol "Filter" needs to be exported by the entry point index.d.ts
    listen<T = any>(threadID: ThreadID, filters: Filter[], callback: (reply?: Instance<T>, err?: Error) => void): grpc.Request;
    newCollection(threadID: ThreadID, name: string, schema: any, indexes?: pb.Index.AsObject[]): Promise<void>;
    newCollectionFromObject(threadID: ThreadID, name: string, obj: any, indexes?: pb.Index.AsObject[]): Promise<void>;
    newDB(threadID?: ThreadID, name?: string): Promise<ThreadID>;
    newDBFromAddr(address: string, key: string | Uint8Array, collections?: Array<{
        name: string;
        schema: any;
    }>): Promise<void>;
    open(threadID: ThreadID, name?: string): Promise<void>;
    static randomIdentity(): Promise<Libp2pCryptoIdentity>;
    // Warning: (ae-forgotten-export) The symbol "ReadTransaction" needs to be exported by the entry point index.d.ts
    readTransaction(threadID: ThreadID, collectionName: string): ReadTransaction;
    // (undocumented)
    rpcOptions: grpc.RpcOptions;
    save(threadID: ThreadID, collectionName: string, values: any[]): Promise<void>;
    // (undocumented)
    serviceHost: string;
    updateCollection(threadID: ThreadID, name: string, schema: any, indexes?: pb.Index.AsObject[]): Promise<void>;
    static withKeyInfo(key: KeyInfo, host?: string, debug?: boolean): Promise<Client>;
    static withUserAuth(auth: UserAuth | (() => Promise<UserAuth>), host?: string, debug?: boolean): Client;
    // Warning: (ae-forgotten-export) The symbol "WriteTransaction" needs to be exported by the entry point index.d.ts
    writeTransaction(threadID: ThreadID, collectionName: string): WriteTransaction;
}

// @public
export function createAPISig(secret: string, date?: Date): Promise<APISig>;

// @public
export function createUserAuth(key: string, secret: string, date?: Date, token?: string): Promise<UserAuth>;

// @public
export const expirationError: Error;

export { Identity }

export { InitReply }

// @public
export type KeyInfo = {
    key: string;
    secret?: string;
};

export { LinksReply }

export { ListIpfsPathReply }

// @public (undocumented)
export type ListPathFlat = ReturnType<typeof listPathFlat>;

// @public
export function listPathFlat(grpc: BucketsGrpcClient, bucketKey: string, path: string, dirs: boolean, depth: number): Promise<string[]>;

export { ListPathItem }

// @public (undocumented)
export type ListPathRecursive = ReturnType<typeof listPathRecursive>;

// @public
export function listPathRecursive(grpc: BucketsGrpcClient, bucketKey: string, path: string, depth: number, currentDepth?: number): Promise<ListPathReply.AsObject>;

export { ListPathReply }

export { ListReply }

export { PullIpfsPathReply }

export { PullPathReply }

export { PushPathReply }

// @public
export interface PushPathResult {
    // (undocumented)
    path: {
        path: string;
        cid: CID;
        root: CID;
        remainder: string;
    };
    // (undocumented)
    root: string;
}

export { RemovePathReply }

export { RemoveReply }

export { Root }

export { RootReply }

export { SetPathReply }

// @public
export class ThreadID {
    constructor(buf: Uint8Array);
    // (undocumented)
    readonly buf: Buffer;
    equals(o: ThreadID): boolean;
    static fromBytes(data: Uint8Array): ThreadID;
    static fromRandom(variant?: Variant, size?: number): ThreadID;
    static fromString(v: string | Uint8Array): ThreadID;
    static getEncoding(v: string): string;
    isDefined(): boolean;
    toBytes(): Buffer;
    toString(base?: name_2): string;
    static V1: number;
    // (undocumented)
    static Variant: typeof Variant;
    variant(): number;
    version(): number;
}

// @public
export type UserAuth = {
    key: string;
    sig: string;
    msg: string;
    token?: string;
};

// @public
export enum Variant {
    // (undocumented)
    AccessControlled = 112,
    // (undocumented)
    Raw = 85
}


```
